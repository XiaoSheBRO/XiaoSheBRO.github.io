import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,e as a,o as e}from"./app-BIBsZUwS.js";const l={};function p(t,n){return e(),o("div",null,n[0]||(n[0]=[a(`<h1 id="入门" tabindex="-1"><a class="header-anchor" href="#入门"><span>入门</span></a></h1><h2 id="时间与空间复杂度" tabindex="-1"><a class="header-anchor" href="#时间与空间复杂度"><span>时间与空间复杂度</span></a></h2><p>数据结构和算法解决是<code>如何让计算机更快时间、更省空间的解决问题</code><br> 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系</p><h3 id="大o表示法" tabindex="-1"><a class="header-anchor" href="#大o表示法"><span>大<code>O</code>表示法</span></a></h3><p>算法的执行时间与每<strong>行</strong>代码的执行次数成正比，总时间 = O(<em>f</em>(n))</p><p><code>O(1)</code>常数阶 &lt; <code>O(log(n))</code>对数阶 &lt; <code>O(n)</code>线性阶 &lt; <code>O(n^2)</code> 平方阶 &lt; <code>O(n^3)</code>(立方阶) &lt; <code>O(2^n)</code> (指数阶)</p><blockquote><p>n 往往表示数据的规模</p></blockquote><h3 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度"><span>时间复杂度</span></a></h3><p>代码执行时间随数据规模增长的<strong>增长趋势</strong></p><blockquote><p>判断一个算法所编程序运行时间的多少，并不是通过程序在计算机上运行所消耗的时间来度量。原因很简单，一方面，解决一个问题的算法可能有很多种，一一实现的工作量无疑是巨大的，得不偿失；另一方面，不同计算机的软、硬件环境不同，程序的运行时间很可能会受影响。</p></blockquote><p>如何预估一个算法所编程序的运行时间呢？很简单，先分别计算程序中每条语句的执行次数，然后用总的执行次数间接表示程序的运行时间。</p><blockquote><p>表示一个算法所编程序运行时间的多少，用的并不是准确值（事实上也无法得出），而是根据合理方法得到的预估值</p></blockquote><div class="language-js" data-highlighter="shiki" data-ext="js" style="background-color:#282A36;color:#f6f6f4;"><pre class="shiki dracula-soft vp-code"><code><span class="line"><span style="color:#F286C4;">for</span><span style="color:#F6F6F4;"> (</span><span style="color:#F286C4;">let</span><span style="color:#F6F6F4;"> i </span><span style="color:#F286C4;">=</span><span style="color:#BF9EEE;"> 0</span><span style="color:#F6F6F4;">; i </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> n; i</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#7B7F8B;">  //从 0 到 n，执行 n+1 次</span></span>
<span class="line"><span style="color:#F6F6F4;">  a</span><span style="color:#F286C4;">++</span><span style="color:#7B7F8B;"> //从 0 到 n-1，执行 n 次</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre></div><blockquote><p>for 循环从 i 的值为 0 一直逐增至 n（注意，循环退出的时候 i 值为 n），因此 for 循环语句执行了 n+1 次；<br> 循环内部仅有一条语句，a++ 从 i 的值为 0 就开始执行，i 的值每增 1 该语句就执行一次，一直到 i 的值为 n-1，因此，a++ 语句一共执行了 n 次。<br> 因此，整段代码中所有语句共执行了 (n+1)+n 次，即 2n+1 次。</p></blockquote><p><strong>数据结构中，每条语句的执行次数，又被称为该语句的频度</strong>，整段代码的总执行次数，即整段代码的频度。</p><div class="language-js" data-highlighter="shiki" data-ext="js" style="background-color:#282A36;color:#f6f6f4;"><pre class="shiki dracula-soft vp-code"><code><span class="line"><span style="color:#F286C4;">for</span><span style="color:#F6F6F4;"> (</span><span style="color:#F286C4;">let</span><span style="color:#F6F6F4;"> i </span><span style="color:#F286C4;">=</span><span style="color:#BF9EEE;"> 0</span><span style="color:#F6F6F4;">; i </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> n; i</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#7B7F8B;">  // n+1</span></span>
<span class="line"><span style="color:#F286C4;">  for</span><span style="color:#F6F6F4;"> (</span><span style="color:#F286C4;">let</span><span style="color:#F6F6F4;"> j </span><span style="color:#F286C4;">=</span><span style="color:#BF9EEE;"> 0</span><span style="color:#F6F6F4;">; j </span><span style="color:#F286C4;">&lt;</span><span style="color:#F6F6F4;"> m; j</span><span style="color:#F286C4;">++</span><span style="color:#F6F6F4;">) {</span></span>
<span class="line"><span style="color:#7B7F8B;">    // n*(m+1)</span></span>
<span class="line"><span style="color:#F6F6F4;">    num</span><span style="color:#F286C4;">++</span><span style="color:#7B7F8B;"> // n*m</span></span>
<span class="line"><span style="color:#F6F6F4;">  }</span></span>
<span class="line"><span style="color:#F6F6F4;">}</span></span></code></pre></div><blockquote><p>计算此段程序的频度为：(n+1)+n*(m+1)+n*m，简化后得 2*n*m+2*n+1。<br> 值得一提的是，不同程序的运行时间，更多场景中比较的是在最坏条件下程序的运行时间，最坏条件即指的是当 n、m 都为无限大时此段程序的运行时&gt; 间。<br> 当 n、m 都无限大时，我们完全就可以认为 n==m。在此基础上，2*n*m+2*n+1 又可以简化为 2*n<sup>2</sup>+2*n+1<br> 类似 2n+1、2*n<sup>2</sup>+2*n+1 这样的频度，还可以再简化吗？答案是肯定的。<br> 以 2n+1 为例，当 n 无限大时，是否在 2n 的基础上再做 +1 操作，并无关紧要，因为 2n 和 2n+1 当 n 无限大时，它们的值是无限接近的。甚至于&gt; 我们还可以认为，当 n 无限大时，是否给 n 乘 2，也是无关紧要的，因为 n 是无限大，2*n 也是无限大。<br> 再以无限大的思想来简化 2*n<sup>2</sup>+2*n+1。当 n 无限大的：<br> 首先，常数 1 是可以忽略不计的；<br> 其次，对于指数级的 2*n<sup>2</sup>来说，是否在其基础上加 2*n，并无关紧要；<br> 甚至于，对于是否给 n<sup>2</sup>  乘 2，也可以忽略。<br> 因此，最终频度 2*n<sup>2</sup>+2*n+1 可以简化为 n<sup>2</sup> 。</p></blockquote><p>在数据结构中，频度表达式可以这样简化：</p><ul><li>去掉频度表达式中，所有的加法常数式子。</li><li>如果表达式有多项含有无限大变量的式子，只保留一个拥有指数最高的变量的式子。</li><li>如果最高项存在系数，且不为 1，直接去掉系数。</li></ul><blockquote><p>事实上，对于一个算法（或者一段程序）来说，其最简频度往往就是最深层次的循环结构中某一条语句的执行次数。例如 2n+1 最简为 n，实际上就是 a++ 语句的执行次数；同样 2n<sup>2</sup>+2n+1 简化为   n<sup>2</sup>，实际上就是最内层循环中 num++ 语句的执行次数。</p></blockquote><ul><li>量级最大法则：忽略常量、低阶和系数</li></ul><blockquote><p>只关注循环执行次数最多的一段代码，执行次数最多的是 for 循环及里面的代码，执行了 n 次，所以时间复杂度为 O(n)</p></blockquote><ul><li>加法法则：总复杂度等于量级最大的那段代码的复杂度，比如一段代码中有单循环和多重循环，那么取多重循环的复杂度</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li><li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加</li></ul><h3 id="空间复杂度" tabindex="-1"><a class="header-anchor" href="#空间复杂度"><span>空间复杂度</span></a></h3><p>算法的存储空间与数据规模之间的增长关系</p><p>每一个算法所编写的程序，运行过程中都需要占用大小不等的存储空间，包括</p><ul><li>程序代码本身所占用的存储空间</li><li>程序中如果需要输入输出数据的存储空间</li><li>程序在运行过程中临时申请的存储空间</li></ul><p>如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为 O(1)；<br> 反之，如果有关，则需要进一步判断它们之间的关系：如果随着输入值 n 的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n) 表示；如果随着输入值 n 的增大，程序申请的临时空间成 n<sup>2</sup> 关系增长，则程序的空间复杂度用 O(n<sup>2</sup>) 表示...</p>`,28)]))}const i=s(l,[["render",p]]),F=JSON.parse(`{"path":"/docs/learning/algorithm/Starter.html","title":"入门","lang":"zh-CN","frontmatter":{"description":"入门 时间与空间复杂度 数据结构和算法解决是如何让计算机更快时间、更省空间的解决问题 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系 大O表示法 算法的执行时间与每行代码的执行次数成正比，总时间 = O(f(n)) O(1)常数阶 < O(log(n))对数阶 < O(n)线性阶 < O(n^2) 平方阶 < O(n^3)(立方阶) < ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"入门\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XiaoSheBRO\\"}]}"],["meta",{"property":"og:url","content":"https://XiaoSheBRO.github.io/docs/learning/algorithm/Starter.html"}],["meta",{"property":"og:site_name","content":"Shaw's Book"}],["meta",{"property":"og:title","content":"入门"}],["meta",{"property":"og:description","content":"入门 时间与空间复杂度 数据结构和算法解决是如何让计算机更快时间、更省空间的解决问题 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系 大O表示法 算法的执行时间与每行代码的执行次数成正比，总时间 = O(f(n)) O(1)常数阶 < O(log(n))对数阶 < O(n)线性阶 < O(n^2) 平方阶 < O(n^3)(立方阶) < ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":7.78,"words":1556},"filePathRelative":"docs/learning/algorithm/Starter.md","autoDesc":true,"excerpt":"\\n<h2>时间与空间复杂度</h2>\\n<p>数据结构和算法解决是<code>如何让计算机更快时间、更省空间的解决问题</code><br>\\n复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系</p>\\n<h3>大<code>O</code>表示法</h3>\\n<p>算法的执行时间与每<strong>行</strong>代码的执行次数成正比，总时间 = O(<em>f</em>(n))</p>\\n<p><code>O(1)</code>常数阶 &lt; <code>O(log(n))</code>对数阶 &lt; <code>O(n)</code>线性阶 &lt; <code>O(n^2)</code> 平方阶 &lt; <code>O(n^3)</code>(立方阶) &lt; <code>O(2^n)</code> (指数阶)</p>"}`);export{i as comp,F as data};
