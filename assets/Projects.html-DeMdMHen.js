import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,e as d,o as r}from"./app-BIBsZUwS.js";const a={};function c(n,e){return r(),o("div",null,e[0]||(e[0]=[d('<h1 id="项目基础" tabindex="-1"><a class="header-anchor" href="#项目基础"><span>项目基础</span></a></h1><h2 id="语义化版本号管理" tabindex="-1"><a class="header-anchor" href="#语义化版本号管理"><span>语义化版本号管理</span></a></h2><p>Node 项目遵循 <a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener noreferrer">语义化版本号</a> 的规则，例如 <code>1.0.0</code> 、 <code>1.0.1</code> 、 <code>1.1.0</code> 这样的版本号，本教材的主角 Vue 也是遵循了语义化版本号的发布规则。</p><p>建议开发者在入门前端工程化的时候就应该熟悉这套规则，后续的项目开发中，你会使用到很多外部依赖，它们也是使用版本号控制来管理代码的发布，每个版本之间可能会有一些兼容性问题，如果不了解版本号的通用规则，很容易在你的开发中带来困扰。</p><p>TIP</p><p>现在有很多 CI/CD 流水线作业具备了根据 Git 的 Commit 记录来自动升级版本号，它们也是遵循了语义化版本号规则，版本号的语义化在前端工程里有重大的意义。</p><h3 id="基本格式与升级规则" tabindex="-1"><a class="header-anchor" href="#基本格式与升级规则"><span>基本格式与升级规则</span></a></h3><p>版本号的格式为： <code>Major.Minor.Patch</code> （简称 <code>X.Y.Z</code> ），它们的含义和升级规则如下：</p><table><thead><tr><th>英文</th><th>中文</th><th>含义</th></tr></thead><tbody><tr><td>Major</td><td>主版本号</td><td>当项目作了大量的变更，与旧版本存在一定的不兼容问题</td></tr><tr><td>Minor</td><td>次版本号</td><td>做了向下兼容的功能改动或者少量功能更新</td></tr><tr><td>Patch</td><td>修订号</td><td>修复上一个版本的少量 BUG</td></tr></tbody></table><p>一般情况下，三者均为正整数，并且从 <code>0</code> 开始，遵循这三条注意事项：</p><ul><li>当主版本号升级时，次版本号和修订号归零</li><li>当次版本号升级时，修订号归零，主版本号保持不变</li><li>当修订号升级时，主版本号和次版本号保持不变</li></ul><p>下面以一些常见的例子帮助你快速理解版本号的升级规则：</p><ul><li>如果不打算发布，可以默认为 <code>0.0.0</code> ，代表它并不是一个进入发布状态的包</li><li>在正式发布之前，你可以将其设置为 <code>0.1.0</code> 发布第一个测试版本，自此，代表已进入发布状态，但还处于初期开发阶段，这个阶段你可能经常改变 API ，但不需要频繁的更新主版本号</li><li>在 <code>0.1.0</code> 发布后，修复了 BUG ，下一个版本号将设置为 <code>0.1.1</code> ，即更新了一个修订号</li><li>在 <code>0.1.1</code> 发布后，有新的功能发布，下一个版本号可以升级为 <code>0.2.0</code> ，即更新了一个次版本号</li><li>当你觉得这个项目已经功能稳定、没有什么 BUG 了，决定正式发布并给用户使用时，那么就可以进入了 <code>1.0.0</code> 正式版了</li></ul><h3 id="版本标识符" tabindex="-1"><a class="header-anchor" href="#版本标识符"><span>版本标识符</span></a></h3><p>以上是一些常规的版本号升级规则，你也可以通过添加 “标识符” 来修饰你的版本更新：</p><p>格式为： <code>Major.Minor.Patch-Identifier.1</code> ，其中的 <code>Identifier</code> 代表 “标识符” ，它和版本号之间使用 <code>-</code> 短横线来连接，后面的 <code>.1</code> 代表当前标识符的第几个版本，每发布一次，这个数字 +1 。</p><table><thead><tr><th>标识符</th><th>含义</th></tr></thead><tbody><tr><td>alpha</td><td>内部版本，代表当前可能有很大的变动</td></tr><tr><td>beta</td><td>测试版本，代表版本已开始稳定，但可能会有比较多的问题需要测试和修复</td></tr><tr><td>rc</td><td>即将作为正式版本发布，只需做最后的验证即可发布正式版</td></tr></tbody></table>',17)]))}const h=t(a,[["render",c]]),l=JSON.parse(`{"path":"/docs/learning/Projects.html","title":"项目基础","lang":"zh-CN","frontmatter":{"description":"项目基础 语义化版本号管理 Node 项目遵循 语义化版本号 的规则，例如 1.0.0 、 1.0.1 、 1.1.0 这样的版本号，本教材的主角 Vue 也是遵循了语义化版本号的发布规则。 建议开发者在入门前端工程化的时候就应该熟悉这套规则，后续的项目开发中，你会使用到很多外部依赖，它们也是使用版本号控制来管理代码的发布，每个版本之间可能会有一些兼容...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"项目基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XiaoSheBRO\\"}]}"],["meta",{"property":"og:url","content":"https://XiaoSheBRO.github.io/docs/learning/Projects.html"}],["meta",{"property":"og:site_name","content":"Shaw's Book"}],["meta",{"property":"og:title","content":"项目基础"}],["meta",{"property":"og:description","content":"项目基础 语义化版本号管理 Node 项目遵循 语义化版本号 的规则，例如 1.0.0 、 1.0.1 、 1.1.0 这样的版本号，本教材的主角 Vue 也是遵循了语义化版本号的发布规则。 建议开发者在入门前端工程化的时候就应该熟悉这套规则，后续的项目开发中，你会使用到很多外部依赖，它们也是使用版本号控制来管理代码的发布，每个版本之间可能会有一些兼容..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":4.18,"words":835},"filePathRelative":"docs/learning/Projects.md","autoDesc":true,"excerpt":"\\n<h2>语义化版本号管理</h2>\\n<p>Node 项目遵循 <a href=\\"https://semver.org/lang/zh-CN/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">语义化版本号</a> 的规则，例如 <code>1.0.0</code> 、 <code>1.0.1</code> 、 <code>1.1.0</code> 这样的版本号，本教材的主角 Vue 也是遵循了语义化版本号的发布规则。</p>\\n<p>建议开发者在入门前端工程化的时候就应该熟悉这套规则，后续的项目开发中，你会使用到很多外部依赖，它们也是使用版本号控制来管理代码的发布，每个版本之间可能会有一些兼容性问题，如果不了解版本号的通用规则，很容易在你的开发中带来困扰。</p>"}`);export{h as comp,l as data};
